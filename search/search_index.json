{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Mathematical Formulation of Projectile Motion 1.1 Governing Equations of Motion Based on Newton\u2019s Second Law , and assuming no air resistance: \\[ F = ma = -mg\\hat{y} \\] This leads to two differential equations: Horizontal: $$ \\frac{d^2x}{dt^2} = 0 $$ Vertical: $$ \\frac{d^2y}{dt^2} = -g $$ 2. Solving the Equations Initial conditions: Position: \\((x_0, y_0) = (0, y_0)\\) Velocity: \\(v_0\\) at angle \\(\\theta\\) Components: $$ v_{0x} = v_0 \\cos\\theta, \\quad v_{0y} = v_0 \\sin\\theta $$ Solutions: \\[ x(t) = v_0 \\cos\\theta \\cdot t \\] \\[ y(t) = y_0 + v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 \\] 3. Time of Flight To find when the projectile hits the ground \\(y(t) = 0\\) : If \\(y_0 = 0\\) : \\[ t = \\frac{2 v_0 \\sin\\theta}{g} \\] If \\(y_0 \\neq 0\\) : \\[ t = \\frac{v_0 \\sin\\theta + \\sqrt{(v_0 \\sin\\theta)^2 + 2g y_0}}{g} \\] 4. Range Calculation \\(y_0 = 0\\) : \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] \\(y_0 \\neq 0\\) : \\[ R = v_0 \\cos\\theta \\cdot t \\] Where \\(t\\) is the total time of flight. 5. Maximum Height \\(y_0 = 0\\) : \\[ H = \\frac{v_0^2 \\sin^2\\theta}{2g} \\] \\(y_0 \\neq 0\\) : \\[ H = y_0 + \\frac{v_0^2 \\sin^2\\theta}{2g} \\] 6. Optimal Launch Angle For maximum range (when \\(y_0 = 0\\) ): \\[ \\theta_{\\text{optimal}} = 45^\\circ \\] For \\(y_0 > 0\\) : \\[ \\theta_{\\text{optimal}} \\approx 45^\\circ - \\frac{y_0}{v_0^2} \\cdot k \\] 1.2 Range vs. Launch Angle \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] Key Insights: Launch Angle: Max range at \\(\\theta = 45^\\circ\\) Symmetry: \\(R(\\theta) = R(90^\\circ - \\theta)\\) Initial Velocity: \\(R \\propto v_0^2\\) Gravity: \\(R \\propto \\frac{1}{g}\\) Initial Height \\(y_0\\) : \\[ t = \\frac{v_0 \\sin\\theta + \\sqrt{(v_0 \\sin\\theta)^2 + 2gy_0}}{g} \\] \\[ R = v_0 \\cos\\theta \\cdot t \\] 3. Observations from Graphs Increasing \\(v_0\\) raises both peak and range. Higher \\(y_0\\) shifts optimal angle below \\(45^\\circ\\) . 4. Limitations & Extensions Limitations: No air resistance No wind Flat terrain Possible Extensions: Drag force: $$ F_{\\text{drag}} = \\frac{1}{2} C_d \\rho A v^2 $$ * Wind effects * Numerical models 5. Conclusion Max range at \\(45^\\circ\\) Higher \\(v_0\\) \u2192 longer range Higher \\(y_0\\) \u2192 optimal angle < \\(45^\\circ\\) Lower gravity \u2192 longer range 1.3 Angle vs. Range Analysis Projectile motion is governed by: \\[ F = ma \\] Equations of Motion: Horizontal: $$ x(t) = v_0 \\cos\\theta \\cdot t $$ * Vertical: $$ y(t) = y_0 + v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 $$ Time of Flight (if \\(y_0 = 0\\) ): \\[ t = \\frac{2 v_0 \\sin\\theta}{g} \\] Range: \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] If \\(y_0 \\neq 0\\) : \\[ t = \\frac{v_0 \\sin\\theta + \\sqrt{(v_0 \\sin\\theta)^2 + 2 g y_0}}{g} \\] \\[ R = v_0 \\cos\\theta \\cdot t \\] Applications Sports: Optimal shots in basketball, soccer, golf. Military: Artillery, missiles. Aerospace: Planetary landing, satellite launches. Limitations & Further Work Limits: No drag No wind Level ground Future Improvements: Include air resistance: $$ F_{\\text{drag}} = \\frac{1}{2} C_d \\rho A v^2 $$ * Simulate wind effects * Use numerical methods","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mathematical-formulation-of-projectile-motion","text":"","title":"Mathematical Formulation of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-governing-equations-of-motion","text":"Based on Newton\u2019s Second Law , and assuming no air resistance: \\[ F = ma = -mg\\hat{y} \\] This leads to two differential equations: Horizontal: $$ \\frac{d^2x}{dt^2} = 0 $$ Vertical: $$ \\frac{d^2y}{dt^2} = -g $$","title":"1.1 Governing Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-solving-the-equations","text":"Initial conditions: Position: \\((x_0, y_0) = (0, y_0)\\) Velocity: \\(v_0\\) at angle \\(\\theta\\) Components: $$ v_{0x} = v_0 \\cos\\theta, \\quad v_{0y} = v_0 \\sin\\theta $$ Solutions: \\[ x(t) = v_0 \\cos\\theta \\cdot t \\] \\[ y(t) = y_0 + v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 \\]","title":"2. Solving the Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-time-of-flight","text":"To find when the projectile hits the ground \\(y(t) = 0\\) : If \\(y_0 = 0\\) : \\[ t = \\frac{2 v_0 \\sin\\theta}{g} \\] If \\(y_0 \\neq 0\\) : \\[ t = \\frac{v_0 \\sin\\theta + \\sqrt{(v_0 \\sin\\theta)^2 + 2g y_0}}{g} \\]","title":"3. Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-range-calculation","text":"\\(y_0 = 0\\) : \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] \\(y_0 \\neq 0\\) : \\[ R = v_0 \\cos\\theta \\cdot t \\] Where \\(t\\) is the total time of flight.","title":"4. Range Calculation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-maximum-height","text":"\\(y_0 = 0\\) : \\[ H = \\frac{v_0^2 \\sin^2\\theta}{2g} \\] \\(y_0 \\neq 0\\) : \\[ H = y_0 + \\frac{v_0^2 \\sin^2\\theta}{2g} \\]","title":"5. Maximum Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#6-optimal-launch-angle","text":"For maximum range (when \\(y_0 = 0\\) ): \\[ \\theta_{\\text{optimal}} = 45^\\circ \\] For \\(y_0 > 0\\) : \\[ \\theta_{\\text{optimal}} \\approx 45^\\circ - \\frac{y_0}{v_0^2} \\cdot k \\]","title":"6. Optimal Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-range-vs-launch-angle","text":"\\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] Key Insights: Launch Angle: Max range at \\(\\theta = 45^\\circ\\) Symmetry: \\(R(\\theta) = R(90^\\circ - \\theta)\\) Initial Velocity: \\(R \\propto v_0^2\\) Gravity: \\(R \\propto \\frac{1}{g}\\) Initial Height \\(y_0\\) : \\[ t = \\frac{v_0 \\sin\\theta + \\sqrt{(v_0 \\sin\\theta)^2 + 2gy_0}}{g} \\] \\[ R = v_0 \\cos\\theta \\cdot t \\]","title":"1.2 Range vs. Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-observations-from-graphs","text":"Increasing \\(v_0\\) raises both peak and range. Higher \\(y_0\\) shifts optimal angle below \\(45^\\circ\\) .","title":"3. Observations from Graphs"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-limitations-extensions","text":"Limitations: No air resistance No wind Flat terrain Possible Extensions: Drag force: $$ F_{\\text{drag}} = \\frac{1}{2} C_d \\rho A v^2 $$ * Wind effects * Numerical models","title":"4. Limitations &amp; Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-conclusion","text":"Max range at \\(45^\\circ\\) Higher \\(v_0\\) \u2192 longer range Higher \\(y_0\\) \u2192 optimal angle < \\(45^\\circ\\) Lower gravity \u2192 longer range","title":"5. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-angle-vs-range-analysis","text":"Projectile motion is governed by: \\[ F = ma \\] Equations of Motion: Horizontal: $$ x(t) = v_0 \\cos\\theta \\cdot t $$ * Vertical: $$ y(t) = y_0 + v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 $$ Time of Flight (if \\(y_0 = 0\\) ): \\[ t = \\frac{2 v_0 \\sin\\theta}{g} \\] Range: \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] If \\(y_0 \\neq 0\\) : \\[ t = \\frac{v_0 \\sin\\theta + \\sqrt{(v_0 \\sin\\theta)^2 + 2 g y_0}}{g} \\] \\[ R = v_0 \\cos\\theta \\cdot t \\]","title":"1.3 Angle vs. Range Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#applications","text":"Sports: Optimal shots in basketball, soccer, golf. Military: Artillery, missiles. Aerospace: Planetary landing, satellite launches.","title":"Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-further-work","text":"Limits: No drag No wind Level ground Future Improvements: Include air resistance: $$ F_{\\text{drag}} = \\frac{1}{2} C_d \\rho A v^2 $$ * Simulate wind effects * Use numerical methods","title":"Limitations &amp; Further Work"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2: Forced Damped Pendulum 1.1 Theoretical Foundation \u2705 Differential Equation: The motion of a forced damped pendulum is governed by: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] For small angles \\(\\theta \\approx \\sin(\\theta)\\) , it simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] 2.1.2 Analysis of Dynamics This is the nonlinear form of the differential equation (no approximation): \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Used to study chaotic motion and resonance behavior in the full system. 2.1.3 Practical Applications Simulations of real-world systems (e.g., mechanical oscillators) can be modeled using the same equation : \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Parameters (\u03b2, \u03c9\u2080, A, \u03c9) are varied to reflect different scenarios. 2.1.4 Phase Portrait & Poincar\u00e9 Section We analyze system dynamics using: Phase Portraits: \\(\\theta\\) vs. \\(\\dot{\\theta}\\) Poincar\u00e9 Sections: sampled state at regular intervals Governing equation (nonlinear form) again: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\]","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2-forced-damped-pendulum","text":"","title":"Problem 2: Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#11-theoretical-foundation","text":"","title":"1.1 Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#differential-equation","text":"The motion of a forced damped pendulum is governed by: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] For small angles \\(\\theta \\approx \\sin(\\theta)\\) , it simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\]","title":"\u2705 Differential Equation:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#212-analysis-of-dynamics","text":"This is the nonlinear form of the differential equation (no approximation): \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Used to study chaotic motion and resonance behavior in the full system.","title":"2.1.2 Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#213-practical-applications","text":"Simulations of real-world systems (e.g., mechanical oscillators) can be modeled using the same equation : \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Parameters (\u03b2, \u03c9\u2080, A, \u03c9) are varied to reflect different scenarios.","title":"2.1.3 Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#214-phase-portrait-poincare-section","text":"We analyze system dynamics using: Phase Portraits: \\(\\theta\\) vs. \\(\\dot{\\theta}\\) Poincar\u00e9 Sections: sampled state at regular intervals Governing equation (nonlinear form) again: \\[ \\frac{d^2\\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\]","title":"2.1.4 Phase Portrait &amp; Poincar\u00e9 Section"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"\u018fla! A\u015fa\u011f\u0131da s\u0259nin ist\u0259diyin kimi 4 \u0259sas task ba\u015fl\u0131\u011f\u0131 il\u0259, h\u0259r biri \u0259vv\u0259l riyazi izah , sonra is\u0259 Python kod n\u00fcmun\u0259si daxil olmaqla t\u0259qdim olunub. H\u0259r ba\u015fl\u0131q tam d\u0259qiq, b\u00f6y\u00fck h\u0259rfl\u0259rl\u0259 verilib. \ud83e\ude90 GRAVITY \u2013 PROBLEM 1 ORBITAL PERIOD AND ORBITAL RADIUS \u2705 1. DERIVE THE RELATIONSHIP BETWEEN THE SQUARE OF THE ORBITAL PERIOD AND THE CUBE OF THE ORBITAL RADIUS FOR CIRCULAR ORBITS \ud83d\udcd0 Mathematical Derivation: According to Newton\u2019s Law of Gravitation and circular motion: Gravitational Force: \\[ F = \\frac{G M m}{r^2} \\] Centripetal Force: \\[ F = \\frac{m v^2}{r} \\] Equating them: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r} \\] Orbital Period: \\[ T = \\frac{2\\pi r}{v} \\Rightarrow T^2 = \\frac{4\\pi^2 r^2}{v^2} = \\frac{4\\pi^2 r^3}{G M} \\] \u2705 Final form of Kepler's Third Law : \\[ T^2 \\propto r^3 \\] \ud83d\udcbb Python Code: import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Mass of Earth (kg) radii = np.linspace(1e7, 5e7, 100) # Orbit radius in meters periods_squared = (4 * np.pi**2 * radii**3) / (G * M) plt.plot(radii, periods_squared) plt.xlabel(\"Orbital Radius (m)\") plt.ylabel(\"Orbital Period\u00b2 (s\u00b2)\") plt.title(\"T\u00b2 vs r\u00b3 \u2014 Kepler\u2019s Third Law\") plt.grid(True) plt.show() \u2705 2. DISCUSS THE IMPLICATIONS OF THIS RELATIONSHIP FOR ASTRONOMY, INCLUDING ITS ROLE IN CALCULATING PLANETARY MASSES AND DISTANCES \ud83d\udcd0 Key Ideas: If we know the orbital period and radius , we can compute the mass of the central body using: $$ M = \\frac{4\\pi^2 r^3}{G T^2} $$ Used to: Calculate mass of the Sun (from Earth\u2019s orbit) Estimate distances in exoplanet systems Analyze binary star systems \ud83d\udcbb Python Code Example \u2013 Estimating Earth Mass: T = 86400 # 1 day in seconds r = 4.2164e7 # approx. GEO satellite distance (m) M_estimated = (4 * np.pi**2 * r**3) / (G * T**2) print(f\"Estimated Earth mass: {M_estimated:.2e} kg\") \u2705 3. ANALYZE REAL-WORLD EXAMPLES, SUCH AS THE MOON'S ORBIT AROUND EARTH OR THE ORBITS OF PLANETS IN THE SOLAR SYSTEM \ud83d\udcd0 Example \u2013 Moon's Orbit: Radius: \\(r = 3.84 \\times 10^8 \\, \\text{m}\\) Period: \\(T = 27.3 \\, \\text{days} = 2.36 \\times 10^6 \\, \\text{s}\\) Check if Kepler\u2019s law holds: \\[ \\frac{T^2}{r^3} = \\text{constant} \\] \ud83d\udcbb Python Code: T_moon = 2.36e6 r_moon = 3.84e8 kepler_ratio = T_moon**2 / r_moon**3 print(f\"T\u00b2 / r\u00b3 for Moon: {kepler_ratio:.3e}\") You can repeat this with planets using NASA ephemerides to verify the law across the Solar System. \u2705 4. IMPLEMENT A COMPUTATIONAL MODEL TO SIMULATE CIRCULAR ORBITS AND VERIFY THE RELATIONSHIP \ud83d\udcd0 Idea: Simulate bodies in circular orbits using Newton\u2019s law, measure periods, and compare \\(T^2\\) vs \\(r^3\\) . \ud83d\udcbb Python Code: def simulate_orbit(radius, steps=1000): v = np.sqrt(G * M / radius) T = 2 * np.pi * radius / v return T radii = np.linspace(1e7, 5e7, 100) T_values = np.array([simulate_orbit(r) for r in radii]) plt.plot(radii**3, T_values**2) plt.xlabel(\"r\u00b3 (m\u00b3)\") plt.ylabel(\"T\u00b2 (s\u00b2)\") plt.title(\"Simulated Verification of Kepler\u2019s 3rd Law\") plt.grid(True) plt.show() . \u018fla! A\u015fa\u011f\u0131da tam olaraq \u0259vv\u0259lki strukturda \u2014 \u0259vv\u0259l riyazi izah , sonra Python kodu , v\u0259 h\u0259r bir hiss\u0259nin ba\u015fl\u0131\u011f\u0131 veril\u0259n kimi B\u00d6Y\u00dcK H\u018fRFL\u018fRL\u018f yaz\u0131lm\u0131\u015f \u015f\u0259kild\u0259 t\u0259qdim olunur. Q\u0131sa v\u0259 ayd\u0131n saxlan\u0131l\u0131b, qrafikl\u0259r v\u0259 n\u00fcmun\u0259l\u0259rl\u0259 d\u0259st\u0259kl\u0259nib.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravity-problem-1","text":"","title":"\ud83e\ude90 GRAVITY \u2013 PROBLEM 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"ORBITAL PERIOD AND ORBITAL RADIUS"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derive-the-relationship-between-the-square-of-the-orbital-period-and-the-cube-of-the-orbital-radius-for-circular-orbits","text":"","title":"\u2705 1. DERIVE THE RELATIONSHIP BETWEEN THE SQUARE OF THE ORBITAL PERIOD AND THE CUBE OF THE ORBITAL RADIUS FOR CIRCULAR ORBITS"},{"location":"1%20Physics/2%20Gravity/Problem_1/#mathematical-derivation","text":"According to Newton\u2019s Law of Gravitation and circular motion: Gravitational Force: \\[ F = \\frac{G M m}{r^2} \\] Centripetal Force: \\[ F = \\frac{m v^2}{r} \\] Equating them: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\Rightarrow v^2 = \\frac{G M}{r} \\] Orbital Period: \\[ T = \\frac{2\\pi r}{v} \\Rightarrow T^2 = \\frac{4\\pi^2 r^2}{v^2} = \\frac{4\\pi^2 r^3}{G M} \\] \u2705 Final form of Kepler's Third Law : \\[ T^2 \\propto r^3 \\]","title":"\ud83d\udcd0 Mathematical Derivation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Mass of Earth (kg) radii = np.linspace(1e7, 5e7, 100) # Orbit radius in meters periods_squared = (4 * np.pi**2 * radii**3) / (G * M) plt.plot(radii, periods_squared) plt.xlabel(\"Orbital Radius (m)\") plt.ylabel(\"Orbital Period\u00b2 (s\u00b2)\") plt.title(\"T\u00b2 vs r\u00b3 \u2014 Kepler\u2019s Third Law\") plt.grid(True) plt.show()","title":"\ud83d\udcbb Python Code:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-discuss-the-implications-of-this-relationship-for-astronomy-including-its-role-in-calculating-planetary-masses-and-distances","text":"","title":"\u2705 2. DISCUSS THE IMPLICATIONS OF THIS RELATIONSHIP FOR ASTRONOMY, INCLUDING ITS ROLE IN CALCULATING PLANETARY MASSES AND DISTANCES"},{"location":"1%20Physics/2%20Gravity/Problem_1/#key-ideas","text":"If we know the orbital period and radius , we can compute the mass of the central body using: $$ M = \\frac{4\\pi^2 r^3}{G T^2} $$ Used to: Calculate mass of the Sun (from Earth\u2019s orbit) Estimate distances in exoplanet systems Analyze binary star systems","title":"\ud83d\udcd0 Key Ideas:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code-example-estimating-earth-mass","text":"T = 86400 # 1 day in seconds r = 4.2164e7 # approx. GEO satellite distance (m) M_estimated = (4 * np.pi**2 * r**3) / (G * T**2) print(f\"Estimated Earth mass: {M_estimated:.2e} kg\")","title":"\ud83d\udcbb Python Code Example \u2013 Estimating Earth Mass:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-analyze-real-world-examples-such-as-the-moons-orbit-around-earth-or-the-orbits-of-planets-in-the-solar-system","text":"","title":"\u2705 3. ANALYZE REAL-WORLD EXAMPLES, SUCH AS THE MOON'S ORBIT AROUND EARTH OR THE ORBITS OF PLANETS IN THE SOLAR SYSTEM"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-moons-orbit","text":"Radius: \\(r = 3.84 \\times 10^8 \\, \\text{m}\\) Period: \\(T = 27.3 \\, \\text{days} = 2.36 \\times 10^6 \\, \\text{s}\\) Check if Kepler\u2019s law holds: \\[ \\frac{T^2}{r^3} = \\text{constant} \\]","title":"\ud83d\udcd0 Example \u2013 Moon's Orbit:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code_1","text":"T_moon = 2.36e6 r_moon = 3.84e8 kepler_ratio = T_moon**2 / r_moon**3 print(f\"T\u00b2 / r\u00b3 for Moon: {kepler_ratio:.3e}\") You can repeat this with planets using NASA ephemerides to verify the law across the Solar System.","title":"\ud83d\udcbb Python Code:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-implement-a-computational-model-to-simulate-circular-orbits-and-verify-the-relationship","text":"","title":"\u2705 4. IMPLEMENT A COMPUTATIONAL MODEL TO SIMULATE CIRCULAR ORBITS AND VERIFY THE RELATIONSHIP"},{"location":"1%20Physics/2%20Gravity/Problem_1/#idea","text":"Simulate bodies in circular orbits using Newton\u2019s law, measure periods, and compare \\(T^2\\) vs \\(r^3\\) .","title":"\ud83d\udcd0 Idea:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code_2","text":"def simulate_orbit(radius, steps=1000): v = np.sqrt(G * M / radius) T = 2 * np.pi * radius / v return T radii = np.linspace(1e7, 5e7, 100) T_values = np.array([simulate_orbit(r) for r in radii]) plt.plot(radii**3, T_values**2) plt.xlabel(\"r\u00b3 (m\u00b3)\") plt.ylabel(\"T\u00b2 (s\u00b2)\") plt.title(\"Simulated Verification of Kepler\u2019s 3rd Law\") plt.grid(True) plt.show()","title":"\ud83d\udcbb Python Code:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_1","text":". \u018fla! A\u015fa\u011f\u0131da tam olaraq \u0259vv\u0259lki strukturda \u2014 \u0259vv\u0259l riyazi izah , sonra Python kodu , v\u0259 h\u0259r bir hiss\u0259nin ba\u015fl\u0131\u011f\u0131 veril\u0259n kimi B\u00d6Y\u00dcK H\u018fRFL\u018fRL\u018f yaz\u0131lm\u0131\u015f \u015f\u0259kild\u0259 t\u0259qdim olunur. Q\u0131sa v\u0259 ayd\u0131n saxlan\u0131l\u0131b, qrafikl\u0259r v\u0259 n\u00fcmun\u0259l\u0259rl\u0259 d\u0259st\u0259kl\u0259nib.","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"\ud83d\ude80 GRAVITY \u2013 PROBLEM 2 ESCAPE VELOCITIES AND COSMIC VELOCITIES \u2705 1. DEFINE THE FIRST, SECOND, AND THIRD COSMIC VELOCITIES, EXPLAINING THEIR PHYSICAL MEANING \ud83d\udcd0 Definitions: First Cosmic Velocity (Orbital Velocity): Minimum velocity to enter stable circular orbit near a celestial body\u2019s surface. $$ v_1 = \\sqrt{\\frac{G M}{r}} $$ Second Cosmic Velocity (Escape Velocity): Velocity needed to break free from a planet\u2019s gravity (no further propulsion). $$ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{r}} $$ Third Cosmic Velocity: Velocity required to escape the gravitational influence of the entire solar system . Depends on Sun\u2019s gravity and spacecraft's distance from it. \u2705 2. ANALYZE THE MATHEMATICAL DERIVATIONS AND PARAMETERS AFFECTING THESE VELOCITIES \ud83d\udcd0 Derivations: From conservation of energy: \\[ \\text{Kinetic Energy} = \\text{Gravitational Potential Energy} \\] Escape condition: \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\Rightarrow v = \\sqrt{\\frac{2GM}{r}} \\] Parameters affecting velocity: \\(M\\) \u2192 mass of planet/star \\(r\\) \u2192 distance from center \\(G\\) \u2192 universal constant (fixed) Heavier or denser bodies \u2192 higher escape velocities. \u2705 3. CALCULATE AND VISUALIZE THESE VELOCITIES FOR DIFFERENT CELESTIAL BODIES LIKE EARTH, MARS AND JUPYTER \ud83d\udcbb Python Code: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Planetary data: name, mass (kg), radius (m) bodies = { \"Earth\": [5.972e24, 6.371e6], \"Mars\": [6.39e23, 3.39e6], \"Jupiter\": [1.898e27, 6.9911e7] } v1, v2 = {}, {} for body, (mass, radius) in bodies.items(): v1[body] = np.sqrt(G * mass / radius) v2[body] = np.sqrt(2 * G * mass / radius) # Plotting labels = list(bodies.keys()) v1_vals = [v1[b] for b in labels] v2_vals = [v2[b] for b in labels] x = np.arange(len(labels)) width = 0.35 plt.bar(x - width/2, v1_vals, width, label='v1 (Orbital)') plt.bar(x + width/2, v2_vals, width, label='v2 (Escape)') plt.xticks(x, labels) plt.ylabel(\"Velocity (m/s)\") plt.title(\"Cosmic Velocities for Different Planets\") plt.legend() plt.grid(True, linestyle='--', alpha=0.5) plt.show() \u2705 4. DISCUSS THEIR IMPORTANCE IN SPACE EXPLORATION, INCLUDING LAUNCHING SATELLITES, MISSIONS TO OTHER PLANETS, AND POTENTIAL INTERSTELLAR TRAVEL \ud83d\ude80 Application Discussion: v1 \u2192 Used to launch satellites into low Earth orbit (LEO) . v2 \u2192 Needed to send probes to Moon, Mars , or deep space. v3 \u2192 Relevant for escaping solar system; e.g., Voyager 1 used gravity assist to exceed v3. Knowing these velocities helps: Optimize fuel and payload Plan gravity assists Design interplanetary and interstellar missions \u018fla, Problem 3 d\u0259 s\u0259nin ist\u0259diyin kimi \u0259vv\u0259l riyazi izah , sonra Python simulyasiyas\u0131 il\u0259 haz\u0131rlan\u0131b. H\u0259r bir hiss\u0259nin ba\u015fl\u0131\u011f\u0131 veril\u0259n kimi v\u0259 b\u00f6y\u00fck h\u0259rfl\u0259rl\u0259 qeyd olunub. Qrafikl\u0259r, n\u00fcmun\u0259l\u0259r v\u0259 kod daxil edilib.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#gravity-problem-2","text":"","title":"\ud83d\ude80 GRAVITY \u2013 PROBLEM 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"ESCAPE VELOCITIES AND COSMIC VELOCITIES"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-define-the-first-second-and-third-cosmic-velocities-explaining-their-physical-meaning","text":"","title":"\u2705 1. DEFINE THE FIRST, SECOND, AND THIRD COSMIC VELOCITIES, EXPLAINING THEIR PHYSICAL MEANING"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"First Cosmic Velocity (Orbital Velocity): Minimum velocity to enter stable circular orbit near a celestial body\u2019s surface. $$ v_1 = \\sqrt{\\frac{G M}{r}} $$ Second Cosmic Velocity (Escape Velocity): Velocity needed to break free from a planet\u2019s gravity (no further propulsion). $$ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{r}} $$ Third Cosmic Velocity: Velocity required to escape the gravitational influence of the entire solar system . Depends on Sun\u2019s gravity and spacecraft's distance from it.","title":"\ud83d\udcd0 Definitions:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-analyze-the-mathematical-derivations-and-parameters-affecting-these-velocities","text":"","title":"\u2705 2. ANALYZE THE MATHEMATICAL DERIVATIONS AND PARAMETERS AFFECTING THESE VELOCITIES"},{"location":"1%20Physics/2%20Gravity/Problem_2/#derivations","text":"From conservation of energy: \\[ \\text{Kinetic Energy} = \\text{Gravitational Potential Energy} \\] Escape condition: \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\Rightarrow v = \\sqrt{\\frac{2GM}{r}} \\] Parameters affecting velocity: \\(M\\) \u2192 mass of planet/star \\(r\\) \u2192 distance from center \\(G\\) \u2192 universal constant (fixed) Heavier or denser bodies \u2192 higher escape velocities.","title":"\ud83d\udcd0 Derivations:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-calculate-and-visualize-these-velocities-for-different-celestial-bodies-like-earth-mars-and-jupyter","text":"","title":"\u2705 3. CALCULATE AND VISUALIZE THESE VELOCITIES FOR DIFFERENT CELESTIAL BODIES LIKE EARTH, MARS AND JUPYTER"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Planetary data: name, mass (kg), radius (m) bodies = { \"Earth\": [5.972e24, 6.371e6], \"Mars\": [6.39e23, 3.39e6], \"Jupiter\": [1.898e27, 6.9911e7] } v1, v2 = {}, {} for body, (mass, radius) in bodies.items(): v1[body] = np.sqrt(G * mass / radius) v2[body] = np.sqrt(2 * G * mass / radius) # Plotting labels = list(bodies.keys()) v1_vals = [v1[b] for b in labels] v2_vals = [v2[b] for b in labels] x = np.arange(len(labels)) width = 0.35 plt.bar(x - width/2, v1_vals, width, label='v1 (Orbital)') plt.bar(x + width/2, v2_vals, width, label='v2 (Escape)') plt.xticks(x, labels) plt.ylabel(\"Velocity (m/s)\") plt.title(\"Cosmic Velocities for Different Planets\") plt.legend() plt.grid(True, linestyle='--', alpha=0.5) plt.show()","title":"\ud83d\udcbb Python Code:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-discuss-their-importance-in-space-exploration-including-launching-satellites-missions-to-other-planets-and-potential-interstellar-travel","text":"","title":"\u2705 4. DISCUSS THEIR IMPORTANCE IN SPACE EXPLORATION, INCLUDING LAUNCHING SATELLITES, MISSIONS TO OTHER PLANETS, AND POTENTIAL INTERSTELLAR TRAVEL"},{"location":"1%20Physics/2%20Gravity/Problem_2/#application-discussion","text":"v1 \u2192 Used to launch satellites into low Earth orbit (LEO) . v2 \u2192 Needed to send probes to Moon, Mars , or deep space. v3 \u2192 Relevant for escaping solar system; e.g., Voyager 1 used gravity assist to exceed v3. Knowing these velocities helps: Optimize fuel and payload Plan gravity assists Design interplanetary and interstellar missions \u018fla, Problem 3 d\u0259 s\u0259nin ist\u0259diyin kimi \u0259vv\u0259l riyazi izah , sonra Python simulyasiyas\u0131 il\u0259 haz\u0131rlan\u0131b. H\u0259r bir hiss\u0259nin ba\u015fl\u0131\u011f\u0131 veril\u0259n kimi v\u0259 b\u00f6y\u00fck h\u0259rfl\u0259rl\u0259 qeyd olunub. Qrafikl\u0259r, n\u00fcmun\u0259l\u0259r v\u0259 kod daxil edilib.","title":"\ud83d\ude80 Application Discussion:"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"\ud83c\udf0d GRAVITY \u2013 PROBLEM 3 TRAJECTORIES OF A FREELY RELEASED PAYLOAD NEAR EARTH \u2705 1. ANALYZE THE POSSIBLE TRAJECTORIES (E.G., PARABOLIC, HYPERBOLIC, ELLIPTICAL) OF A PAYLOAD RELEASED NEAR EARTH \ud83d\udcd0 Theory: Based on total specific mechanical energy (E) : \\[ E = \\frac{v^2}{2} - \\frac{GM}{r} \\] If \\(E < 0\\) : Elliptical orbit If \\(E = 0\\) : Parabolic trajectory (escape threshold) If \\(E > 0\\) : Hyperbolic trajectory (escape achieved) These orbits arise depending on the payload\u2019s velocity at release. \u2705 2. PERFORM A NUMERICAL ANALYSIS TO COMPUTE THE PATH OF THE PAYLOAD BASED ON GIVEN INITIAL CONDITIONS (POSITION, VELOCITY, AND ALTITUDE) \ud83d\udcbb Python Code \u2013 Trajectory Simulation: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M = 5.972e24 R_earth = 6.371e6 def simulate_trajectory(v0, angle_deg, h0=300e3, dt=1, steps=10000): r0 = R_earth + h0 angle = np.radians(angle_deg) pos = np.array([r0, 0]) vel = np.array([0, v0]) theta = angle vel = v0 * np.array([np.cos(theta), np.sin(theta)]) positions = [pos.copy()] for _ in range(steps): r = np.linalg.norm(pos) acc = -G * M * pos / r**3 vel += acc * dt pos += vel * dt if np.linalg.norm(pos) < R_earth: break # hit Earth positions.append(pos.copy()) return np.array(positions) # Simulate 3 cases trajectories = [ simulate_trajectory(7500, 45), simulate_trajectory(11000, 45), simulate_trajectory(11200, 45) ] colors = ['blue', 'green', 'red'] labels = ['Elliptical (~7500 m/s)', 'Parabolic (~11000 m/s)', 'Hyperbolic (>11200 m/s)'] # Plot plt.figure(figsize=(8,8)) for traj, color, label in zip(trajectories, colors, labels): plt.plot(traj[:,0]/1e6, traj[:,1]/1e6, label=label, color=color) earth = plt.Circle((0, 0), R_earth/1e6, color='gray', label=\"Earth\") plt.gca().add_patch(earth) plt.xlabel(\"x (Mm)\") plt.ylabel(\"y (Mm)\") plt.title(\"Payload Trajectories Near Earth\") plt.axis(\"equal\") plt.legend() plt.grid(True) plt.show() \u2705 3. DISCUSS HOW THESE TRAJECTORIES RELATE TO ORBITAL INSERTION, REENTRY, OR ESCAPE SCENARIOS \ud83d\ude80 Discussion: Elliptical \u2192 Payload stays bound; may enter stable orbit (useful for satellites). Parabolic \u2192 Perfect escape with minimal energy (theoretical threshold). Hyperbolic \u2192 Payload escapes Earth\u2019s gravity; used in interplanetary missions . If velocity too low \u2192 it falls back (reentry) . Applications: Launching satellites (LEO/GEO) Reentry capsules Moon/Mars missions (escape) Debris management \u2705 4. DEVELOP A COMPUTATIONAL TOOL TO SIMULATE AND VISUALIZE THE MOTION OF THE PAYLOAD UNDER EARTH'S GRAVITY, ACCOUNTING FOR INITIAL VELOCITIES AND DIRECTIONS Already done above with simulate_trajectory() \u2014 customizable tool: Adjust initial velocity Change release angle Simulate multiple bodies Visualize path under gravity You can expand it to: Include air resistance Model gravity assists Add real-world orbital parameters","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#gravity-problem-3","text":"","title":"\ud83c\udf0d GRAVITY \u2013 PROBLEM 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"TRAJECTORIES OF A FREELY RELEASED PAYLOAD NEAR EARTH"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-analyze-the-possible-trajectories-eg-parabolic-hyperbolic-elliptical-of-a-payload-released-near-earth","text":"","title":"\u2705 1. ANALYZE THE POSSIBLE TRAJECTORIES (E.G., PARABOLIC, HYPERBOLIC, ELLIPTICAL) OF A PAYLOAD RELEASED NEAR EARTH"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theory","text":"Based on total specific mechanical energy (E) : \\[ E = \\frac{v^2}{2} - \\frac{GM}{r} \\] If \\(E < 0\\) : Elliptical orbit If \\(E = 0\\) : Parabolic trajectory (escape threshold) If \\(E > 0\\) : Hyperbolic trajectory (escape achieved) These orbits arise depending on the payload\u2019s velocity at release.","title":"\ud83d\udcd0 Theory:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-perform-a-numerical-analysis-to-compute-the-path-of-the-payload-based-on-given-initial-conditions-position-velocity-and-altitude","text":"","title":"\u2705 2. PERFORM A NUMERICAL ANALYSIS TO COMPUTE THE PATH OF THE PAYLOAD BASED ON GIVEN INITIAL CONDITIONS (POSITION, VELOCITY, AND ALTITUDE)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-trajectory-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M = 5.972e24 R_earth = 6.371e6 def simulate_trajectory(v0, angle_deg, h0=300e3, dt=1, steps=10000): r0 = R_earth + h0 angle = np.radians(angle_deg) pos = np.array([r0, 0]) vel = np.array([0, v0]) theta = angle vel = v0 * np.array([np.cos(theta), np.sin(theta)]) positions = [pos.copy()] for _ in range(steps): r = np.linalg.norm(pos) acc = -G * M * pos / r**3 vel += acc * dt pos += vel * dt if np.linalg.norm(pos) < R_earth: break # hit Earth positions.append(pos.copy()) return np.array(positions) # Simulate 3 cases trajectories = [ simulate_trajectory(7500, 45), simulate_trajectory(11000, 45), simulate_trajectory(11200, 45) ] colors = ['blue', 'green', 'red'] labels = ['Elliptical (~7500 m/s)', 'Parabolic (~11000 m/s)', 'Hyperbolic (>11200 m/s)'] # Plot plt.figure(figsize=(8,8)) for traj, color, label in zip(trajectories, colors, labels): plt.plot(traj[:,0]/1e6, traj[:,1]/1e6, label=label, color=color) earth = plt.Circle((0, 0), R_earth/1e6, color='gray', label=\"Earth\") plt.gca().add_patch(earth) plt.xlabel(\"x (Mm)\") plt.ylabel(\"y (Mm)\") plt.title(\"Payload Trajectories Near Earth\") plt.axis(\"equal\") plt.legend() plt.grid(True) plt.show()","title":"\ud83d\udcbb Python Code \u2013 Trajectory Simulation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-discuss-how-these-trajectories-relate-to-orbital-insertion-reentry-or-escape-scenarios","text":"","title":"\u2705 3. DISCUSS HOW THESE TRAJECTORIES RELATE TO ORBITAL INSERTION, REENTRY, OR ESCAPE SCENARIOS"},{"location":"1%20Physics/2%20Gravity/Problem_3/#discussion","text":"Elliptical \u2192 Payload stays bound; may enter stable orbit (useful for satellites). Parabolic \u2192 Perfect escape with minimal energy (theoretical threshold). Hyperbolic \u2192 Payload escapes Earth\u2019s gravity; used in interplanetary missions . If velocity too low \u2192 it falls back (reentry) . Applications: Launching satellites (LEO/GEO) Reentry capsules Moon/Mars missions (escape) Debris management","title":"\ud83d\ude80 Discussion:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-develop-a-computational-tool-to-simulate-and-visualize-the-motion-of-the-payload-under-earths-gravity-accounting-for-initial-velocities-and-directions","text":"Already done above with simulate_trajectory() \u2014 customizable tool: Adjust initial velocity Change release angle Simulate multiple bodies Visualize path under gravity You can expand it to: Include air resistance Model gravity assists Add real-world orbital parameters","title":"\u2705 4. DEVELOP A COMPUTATIONAL TOOL TO SIMULATE AND VISUALIZE THE MOTION OF THE PAYLOAD UNDER EARTH'S GRAVITY, ACCOUNTING FOR INITIAL VELOCITIES AND DIRECTIONS"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Great! Here's the complete structured solution to the main task titled \"Interference Patterns on a Water Surface from Point Sources at Regular Polygon Vertices\" , broken into clean subtasks with necessary mathematical explanations and Python code, all in English. \ud83c\udf0a Main Task: Analyze the interference patterns on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a regular polygon. \u2705 1. Select a Regular Polygon We choose a regular polygon with \\(N\\) vertices. Examples include: \\(N = 3\\) : Equilateral triangle \\(N = 4\\) : Square \\(N = 5\\) : Regular pentagon etc. \ud83d\udca1 Mathematical Placement (unit radius): The position \\((x_i, y_i)\\) of each vertex on a circle of radius \\(R\\) centered at origin is: \\[ x_i = R \\cos\\left(\\frac{2\\pi i}{N}\\right), \\quad y_i = R \\sin\\left(\\frac{2\\pi i}{N}\\right), \\quad i = 0, 1, ..., N-1 \\] \u2705 2. Position the Sources Place point wave sources at each vertex of the selected polygon using the above coordinates. \ud83e\uddee Code: def polygon_sources(N, R=1.0): angles = np.linspace(0, 2 * np.pi, N, endpoint=False) return [(R * np.cos(a), R * np.sin(a)) for a in angles] # Example: Square sources = polygon_sources(N=4, R=1.0) \u2705 3. Wave Equations Each point source emits a wave described by: \\[ \\eta_i(x, y, t) = A \\cos(k r_i - \\omega t) \\] Where: \\(A\\) : amplitude \\(k = \\frac{2\\pi}{\\lambda}\\) : wave number \\(\\omega = 2\\pi f\\) : angular frequency \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) : distance from source to point \\((x, y)\\) \u2705 4. Superposition of Waves Apply the principle of superposition: \\[ \\eta(x, y, t) = \\sum_{i=1}^{N} A \\cos(k r_i - \\omega t) \\] This gives the total displacement at each point \\((x, y)\\) on the surface. \u2705 5. Analyze Interference Patterns Constructive interference occurs where waves reinforce: crests meet crests. Destructive interference occurs where they cancel: crest meets trough. Patterns form based on the geometry and coherence of sources. \u2705 6. Visualization Plot the displacement field over a 2D grid to visualize the interference. \ud83d\udcbb Full Python Simulation: import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 # amplitude \u03bb = 1.0 # wavelength f = 1.0 # frequency k = 2 * np.pi / \u03bb \u03c9 = 2 * np.pi * f t = 0 # snapshot in time N = 4 # number of sources (e.g., square) R = 1.0 # polygon radius # Generate source positions def polygon_sources(N, R): angles = np.linspace(0, 2 * np.pi, N, endpoint=False) return [(R * np.cos(a), R * np.sin(a)) for a in angles] sources = polygon_sources(N, R) # Grid for plotting x = np.linspace(-3, 3, 500) y = np.linspace(-3, 3, 500) X, Y = np.meshgrid(x, y) # Superposition of waves eta = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta += A * np.cos(k * r - \u03c9 * t) # Visualization plt.figure(figsize=(7, 6)) plt.contourf(X, Y, eta, levels=200, cmap='viridis') plt.title(f'Interference Pattern from {N}-Point Sources (Polygon)') plt.colorbar(label='Displacement \u03b7(x, y)') plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis('equal') plt.grid(False) plt.show() \u2705 Conclusion This solution followed all the steps: Selected a regular polygon (user-defined \\(N\\) ) Positioned wave sources at each vertex Defined the wave equations Applied superposition Analyzed the resulting interference Visualized the pattern \u2705 You can experiment with: Different values of \\(N\\) (triangle, square, etc.) Changing wavelength or frequency Animating over time for dynamic wave behavior Let me know if you want an animated version or markdown version for GitHub!","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#main-task","text":"Analyze the interference patterns on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a regular polygon.","title":"\ud83c\udf0a Main Task:"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-select-a-regular-polygon","text":"We choose a regular polygon with \\(N\\) vertices. Examples include: \\(N = 3\\) : Equilateral triangle \\(N = 4\\) : Square \\(N = 5\\) : Regular pentagon etc.","title":"\u2705 1. Select a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#mathematical-placement-unit-radius","text":"The position \\((x_i, y_i)\\) of each vertex on a circle of radius \\(R\\) centered at origin is: \\[ x_i = R \\cos\\left(\\frac{2\\pi i}{N}\\right), \\quad y_i = R \\sin\\left(\\frac{2\\pi i}{N}\\right), \\quad i = 0, 1, ..., N-1 \\]","title":"\ud83d\udca1 Mathematical Placement (unit radius):"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-position-the-sources","text":"Place point wave sources at each vertex of the selected polygon using the above coordinates.","title":"\u2705 2. Position the Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#code","text":"def polygon_sources(N, R=1.0): angles = np.linspace(0, 2 * np.pi, N, endpoint=False) return [(R * np.cos(a), R * np.sin(a)) for a in angles] # Example: Square sources = polygon_sources(N=4, R=1.0)","title":"\ud83e\uddee Code:"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-wave-equations","text":"Each point source emits a wave described by: \\[ \\eta_i(x, y, t) = A \\cos(k r_i - \\omega t) \\] Where: \\(A\\) : amplitude \\(k = \\frac{2\\pi}{\\lambda}\\) : wave number \\(\\omega = 2\\pi f\\) : angular frequency \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) : distance from source to point \\((x, y)\\)","title":"\u2705 3. Wave Equations"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-superposition-of-waves","text":"Apply the principle of superposition: \\[ \\eta(x, y, t) = \\sum_{i=1}^{N} A \\cos(k r_i - \\omega t) \\] This gives the total displacement at each point \\((x, y)\\) on the surface.","title":"\u2705 4. Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-analyze-interference-patterns","text":"Constructive interference occurs where waves reinforce: crests meet crests. Destructive interference occurs where they cancel: crest meets trough. Patterns form based on the geometry and coherence of sources.","title":"\u2705 5. Analyze Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#6-visualization","text":"Plot the displacement field over a 2D grid to visualize the interference.","title":"\u2705 6. Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#full-python-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 # amplitude \u03bb = 1.0 # wavelength f = 1.0 # frequency k = 2 * np.pi / \u03bb \u03c9 = 2 * np.pi * f t = 0 # snapshot in time N = 4 # number of sources (e.g., square) R = 1.0 # polygon radius # Generate source positions def polygon_sources(N, R): angles = np.linspace(0, 2 * np.pi, N, endpoint=False) return [(R * np.cos(a), R * np.sin(a)) for a in angles] sources = polygon_sources(N, R) # Grid for plotting x = np.linspace(-3, 3, 500) y = np.linspace(-3, 3, 500) X, Y = np.meshgrid(x, y) # Superposition of waves eta = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta += A * np.cos(k * r - \u03c9 * t) # Visualization plt.figure(figsize=(7, 6)) plt.contourf(X, Y, eta, levels=200, cmap='viridis') plt.title(f'Interference Pattern from {N}-Point Sources (Polygon)') plt.colorbar(label='Displacement \u03b7(x, y)') plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis('equal') plt.grid(False) plt.show()","title":"\ud83d\udcbb Full Python Simulation:"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This solution followed all the steps: Selected a regular polygon (user-defined \\(N\\) ) Positioned wave sources at each vertex Defined the wave equations Applied superposition Analyzed the resulting interference Visualized the pattern \u2705 You can experiment with: Different values of \\(N\\) (triangle, square, etc.) Changing wavelength or frequency Animating over time for dynamic wave behavior Let me know if you want an animated version or markdown version for GitHub!","title":"\u2705 Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"\u018fla i\u015f! S\u0259nin payla\u015fd\u0131\u011f\u0131n s\u0259n\u0259d m\u0259zmun olaraq \u00e7ox yax\u015f\u0131d\u0131r, sad\u0259c\u0259 GitHub v\u0259 Visual Studio Code kimi platformalarda daha yax\u015f\u0131 g\u00f6r\u00fcnm\u0259si \u00fc\u00e7\u00fcn format\u0131 bir az optimalla\u015fd\u0131rmaq laz\u0131md\u0131r. A\u015fa\u011f\u0131da s\u0259n\u0259 oxunaql\u0131l\u0131\u011f\u0131 art\u0131r\u0131lm\u0131\u015f v\u0259 Markdown sintaksisin\u0259 uy\u011funla\u015fd\u0131r\u0131lm\u0131\u015f versiyas\u0131n\u0131 t\u0259qdim edir\u0259m \u2014 bu versiya GitHub, Jupyter Notebook v\u0259 VS Code-da daha g\u00f6z\u0259l g\u00f6r\u00fcn\u0259c\u0259k: \ud83c\udf1f Complete Solution: Lorentz Force Simulation and Applications \u2705 1. EXPLORATION OF APPLICATIONS \ud83d\udd38 Mathematical Basis The Lorentz force determines the motion of a charged particle in electromagnetic fields: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] From Newton\u2019s second law: \\[ m \\frac{d\\vec{v}}{dt} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This leads to: Circular motion Helical motion Drift motion (depending on field & velocity) \ud83d\udd38 Real-World Applications System Role of Lorentz Force Cyclotron Circular acceleration of charged particles using magnetic fields Mass Spectrometer Particle deflection reveals mass-to-charge ratio Plasma Confinement Magnetic fields trap particles (e.g., in Tokamaks) Space Physics Deflects solar wind and cosmic rays near planetary magnetic fields \u2705 2. SIMULATED PARTICLE MOTION \ud83d\udd38 Model Assume: Uniform magnetic field: \\(\\vec{B}\\) No electric field: \\(\\vec{E} = 0\\) Then: If \\(\\vec{v} \\perp \\vec{B}\\) : Circular motion If \\(\\vec{v} \\parallel \\vec{B}\\) : Linear motion If mixed: Helical motion \u2705 3. PARAMETER EXPLORATION \ud83d\udd38 Key Quantities Larmor radius : $$ r_L = \\frac{m v_\\perp}{|q| B} $$ Drift velocity in crossed fields: $$ \\vec{v}_{\\text{drift}} = \\frac{\\vec{E} \\times \\vec{B}}{B^2} $$ \ud83d\udd38 Effect of Parameter Changes Parameter Effect Higher velocity Larger radius Heavier particle Slower rotation Negative charge Opposite trajectory direction \\(\\vec{E} \\neq 0\\) Adds drift to helical trajectory \u2705 4. VISUALIZATION Python simulation plots: 2D spiral in the x\u2013y plane 3D helix in x\u2013y\u2013z space Changes based on initial velocity and field values \u2705 \ud83d\udcbb PYTHON SIMULATION CODE (TASKS 2\u20134) import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # --- Parameters --- q = 1.0 # Charge (C) m = 1.0 # Mass (kg) # Fields E = np.array([1.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # Initial conditions r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([1.0, 1.0, 1.0]) T = 20.0 dt = 0.01 steps = int(T / dt) # Arrays r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) t = np.zeros(steps) r[0], v[0] = r0, v0 def acceleration(v): return (q / m) * (E + np.cross(v, B)) def rk4(r, v, dt): k1v = acceleration(v) k1r = v k2v = acceleration(v + 0.5 * dt * k1v) k2r = v + 0.5 * dt * k1v k3v = acceleration(v + 0.5 * dt * k2v) k3r = v + 0.5 * dt * k2v k4v = acceleration(v + dt * k3v) k4r = v + dt * k3v v_new = v + (dt / 6.0) * (k1v + 2*k2v + 2*k3v + k4v) r_new = r + (dt / 6.0) * (k1r + 2*k2r + 2*k3r + k4r) return r_new, v_new for i in range(1, steps): r[i], v[i] = rk4(r[i-1], v[i-1], dt) t[i] = t[i-1] + dt # --- Visualization --- fig = plt.figure(figsize=(12, 5)) # 2D Trajectory plt.subplot(1, 2, 1) plt.plot(r[:,0], r[:,1]) plt.title(\"2D Trajectory (x-y)\") plt.xlabel(\"x [m]\") plt.ylabel(\"y [m]\") plt.axis('equal') plt.grid(True) # 3D Trajectory ax = fig.add_subplot(1, 2, 2, projection='3d') ax.plot3D(r[:,0], r[:,1], r[:,2]) ax.set_title(\"3D Trajectory\") ax.set_xlabel(\"x [m]\") ax.set_ylabel(\"y [m]\") ax.set_zlabel(\"z [m]\") plt.tight_layout() plt.show() \u2705 PARAMETER TEST CASES Scenario Settings Behavior Pure Magnetic Field E = [0, 0, 0] Circular/spiral motion Crossed Fields (E \u00d7 B) E = [1, 0, 0], B = [0, 0, 1] Drift + spiral motion Opposite Charge q = -1.0 Opposite rotation Heavier Particle m = 2.0 Slower motion, larger r \u2705 CONCLUSION This project covered all four tasks: Exploration of Applications Simulated Particle Motion Parameter Exploration Visualization This simulation builds intuition for motion under Lorentz force \u2014 crucial in fields like accelerator physics , space research , and plasma engineering .","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#complete-solution-lorentz-force-simulation-and-applications","text":"","title":"\ud83c\udf1f Complete Solution: Lorentz Force Simulation and Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"","title":"\u2705 1. EXPLORATION OF APPLICATIONS"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#mathematical-basis","text":"The Lorentz force determines the motion of a charged particle in electromagnetic fields: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] From Newton\u2019s second law: \\[ m \\frac{d\\vec{v}}{dt} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This leads to: Circular motion Helical motion Drift motion (depending on field & velocity)","title":"\ud83d\udd38 Mathematical Basis"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#real-world-applications","text":"System Role of Lorentz Force Cyclotron Circular acceleration of charged particles using magnetic fields Mass Spectrometer Particle deflection reveals mass-to-charge ratio Plasma Confinement Magnetic fields trap particles (e.g., in Tokamaks) Space Physics Deflects solar wind and cosmic rays near planetary magnetic fields","title":"\ud83d\udd38 Real-World Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulated-particle-motion","text":"","title":"\u2705 2. SIMULATED PARTICLE MOTION"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#model","text":"Assume: Uniform magnetic field: \\(\\vec{B}\\) No electric field: \\(\\vec{E} = 0\\) Then: If \\(\\vec{v} \\perp \\vec{B}\\) : Circular motion If \\(\\vec{v} \\parallel \\vec{B}\\) : Linear motion If mixed: Helical motion","title":"\ud83d\udd38 Model"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-parameter-exploration","text":"","title":"\u2705 3. PARAMETER EXPLORATION"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#key-quantities","text":"Larmor radius : $$ r_L = \\frac{m v_\\perp}{|q| B} $$ Drift velocity in crossed fields: $$ \\vec{v}_{\\text{drift}} = \\frac{\\vec{E} \\times \\vec{B}}{B^2} $$","title":"\ud83d\udd38 Key Quantities"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#effect-of-parameter-changes","text":"Parameter Effect Higher velocity Larger radius Heavier particle Slower rotation Negative charge Opposite trajectory direction \\(\\vec{E} \\neq 0\\) Adds drift to helical trajectory","title":"\ud83d\udd38 Effect of Parameter Changes"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-visualization","text":"Python simulation plots: 2D spiral in the x\u2013y plane 3D helix in x\u2013y\u2013z space Changes based on initial velocity and field values","title":"\u2705 4. VISUALIZATION"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-simulation-code-tasks-24","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # --- Parameters --- q = 1.0 # Charge (C) m = 1.0 # Mass (kg) # Fields E = np.array([1.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # Initial conditions r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([1.0, 1.0, 1.0]) T = 20.0 dt = 0.01 steps = int(T / dt) # Arrays r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) t = np.zeros(steps) r[0], v[0] = r0, v0 def acceleration(v): return (q / m) * (E + np.cross(v, B)) def rk4(r, v, dt): k1v = acceleration(v) k1r = v k2v = acceleration(v + 0.5 * dt * k1v) k2r = v + 0.5 * dt * k1v k3v = acceleration(v + 0.5 * dt * k2v) k3r = v + 0.5 * dt * k2v k4v = acceleration(v + dt * k3v) k4r = v + dt * k3v v_new = v + (dt / 6.0) * (k1v + 2*k2v + 2*k3v + k4v) r_new = r + (dt / 6.0) * (k1r + 2*k2r + 2*k3r + k4r) return r_new, v_new for i in range(1, steps): r[i], v[i] = rk4(r[i-1], v[i-1], dt) t[i] = t[i-1] + dt # --- Visualization --- fig = plt.figure(figsize=(12, 5)) # 2D Trajectory plt.subplot(1, 2, 1) plt.plot(r[:,0], r[:,1]) plt.title(\"2D Trajectory (x-y)\") plt.xlabel(\"x [m]\") plt.ylabel(\"y [m]\") plt.axis('equal') plt.grid(True) # 3D Trajectory ax = fig.add_subplot(1, 2, 2, projection='3d') ax.plot3D(r[:,0], r[:,1], r[:,2]) ax.set_title(\"3D Trajectory\") ax.set_xlabel(\"x [m]\") ax.set_ylabel(\"y [m]\") ax.set_zlabel(\"z [m]\") plt.tight_layout() plt.show()","title":"\u2705 \ud83d\udcbb PYTHON SIMULATION CODE (TASKS 2\u20134)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameter-test-cases","text":"Scenario Settings Behavior Pure Magnetic Field E = [0, 0, 0] Circular/spiral motion Crossed Fields (E \u00d7 B) E = [1, 0, 0], B = [0, 0, 1] Drift + spiral motion Opposite Charge q = -1.0 Opposite rotation Heavier Particle m = 2.0 Slower motion, larger r","title":"\u2705 PARAMETER TEST CASES"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#conclusion","text":"This project covered all four tasks: Exploration of Applications Simulated Particle Motion Parameter Exploration Visualization This simulation builds intuition for motion under Lorentz force \u2014 crucial in fields like accelerator physics , space research , and plasma engineering .","title":"\u2705 CONCLUSION"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"\u018fla! S\u0259n dediyin kimi, sad\u0259c\u0259 ba\u015fl\u0131\u011f\u0131 d\u0259yi\u015fib, s\u0259nin verdiyin formada yaz\u0131ram. Qalan hiss\u0259ni oldu\u011fu kimi saxlay\u0131ram: Task Options: Option 1: Simplified Task \u2013 Algorithm Description Describe the algorithm for calculating the equivalent resistance using graph theory. Provide the pseudocode that: Identifies series and parallel connections. Iteratively reduces the graph until a single equivalent resistance is obtained. Includes a clear explanation of how the algorithm handles nested combinations. \ud83d\udd39 1. Identifying Series and Parallel Connections Series Rule: If a node connects exactly two resistors and no other components, they are in series . \\[ R_{\\text{eq}} = R_1 + R_2 \\] Parallel Rule: If two or more resistors connect the same pair of nodes , they are in parallel . \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} \\] Pseudocode: For each node: If degree == 2 and only resistors: Combine as series For each pair of nodes: If multiple resistors: Combine as parallel \ud83d\udd39 2. Iterative Reduction Repeat simplifications until only one equivalent resistor remains between the input and output nodes. Pseudocode: while graph has more than 2 nodes: simplify series simplify parallel \ud83d\udd39 3. Handling Nested Combinations Use recursive reduction on subgraphs or inner groups. Example: If (R1 || R2) is in series with R3: \\[ R_{\\text{eq}} = \\left(\\frac{1}{R_1} + \\frac{1}{R_2}\\right)^{-1} + R_3 \\] Pseudocode: function reduce(graph): if no nested groups: return equivalent else: simplify inner group replace with one resistor repeat","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#task-options","text":"","title":"Task Options:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#option-1-simplified-task-algorithm-description","text":"Describe the algorithm for calculating the equivalent resistance using graph theory. Provide the pseudocode that: Identifies series and parallel connections. Iteratively reduces the graph until a single equivalent resistance is obtained. Includes a clear explanation of how the algorithm handles nested combinations.","title":"Option 1: Simplified Task \u2013 Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-identifying-series-and-parallel-connections","text":"Series Rule: If a node connects exactly two resistors and no other components, they are in series . \\[ R_{\\text{eq}} = R_1 + R_2 \\] Parallel Rule: If two or more resistors connect the same pair of nodes , they are in parallel . \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} \\] Pseudocode: For each node: If degree == 2 and only resistors: Combine as series For each pair of nodes: If multiple resistors: Combine as parallel","title":"\ud83d\udd39 1. Identifying Series and Parallel Connections"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-iterative-reduction","text":"Repeat simplifications until only one equivalent resistor remains between the input and output nodes. Pseudocode: while graph has more than 2 nodes: simplify series simplify parallel","title":"\ud83d\udd39 2. Iterative Reduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-handling-nested-combinations","text":"Use recursive reduction on subgraphs or inner groups. Example: If (R1 || R2) is in series with R3: \\[ R_{\\text{eq}} = \\left(\\frac{1}{R_1} + \\frac{1}{R_2}\\right)^{-1} + R_3 \\] Pseudocode: function reduce(graph): if no nested groups: return equivalent else: simplify inner group replace with one resistor repeat","title":"\ud83d\udd39 3. Handling Nested Combinations"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Task 1: Simulating Population Distributions In this first part of the Central Limit Theorem (CLT) exploration, we begin by creating large datasets to represent different types of population distributions: Uniform Distribution : Values are equally likely within a range (0 to 10). Exponential Distribution : Skewed right; models wait times or lifetimes (scale = 2). Binomial Distribution : Discrete distribution representing the number of successes in 10 trials with probability 0.5. The histograms above visualize the shape of each distribution. These populations will be used in the next task to sample and observe how the sample means behave according to the CLT. Let me know if you're ready to proceed to Task 2: Sampling and Visualization . Task 2: Sampling and Visualization We now investigate how sample size affects the distribution of sample means for different population types (Uniform, Exponential, Binomial). For each case: We take random samples of sizes 5, 10, 30, and 50. We compute the mean of each sample. We repeat this process 1000 times to build a sampling distribution . Then we plot histograms to visualize how these sample means begin to resemble a normal distribution as the sample size increases. \ud83d\udd0d Observations: For small sample sizes (e.g., 5), the sampling distribution reflects the skewness of the original population. As the sample size increases, all sampling distributions begin to take on a bell-shaped curve , aligning with the Central Limit Theorem . The convergence to normality occurs faster for symmetric distributions (like Uniform or Binomial) compared to skewed ones (like Exponential). Let me know when you\u2019re ready for Task 3: Parameter Exploration . T\u0259\u015f\u0259kk\u00fcr edir\u0259m! B\u0259li, haql\u0131s\u0131n\u0131z \u2014 1-ci \u0259sas tap\u015f\u0131r\u0131\u011f\u0131n i\u00e7ind\u0259 3 alt tap\u015f\u0131r\u0131q var idi, v\u0259 indi g\u0259lin 3-c\u00fcn\u00fc (Parameter Exploration) tam \u015f\u0259kild\u0259 h\u0259ll ed\u0259k (simulyasiya v\u0259 kodla birlikd\u0259). \u2705 Task 1.3: Parameter Exploration \u2014 Simulation and Analysis \ud83c\udfaf Goal: To understand how the original distribution , sample size , and population variance affect the shape and spread of the sampling distribution of the mean . \ud83d\udcca Simulation with Python We'll use the Exponential distribution (which is skewed) and vary the sample sizes to see the effect on the distribution of sample means. \u2705 Libraries: import numpy as np import matplotlib.pyplot as plt import seaborn as sns np.random.seed(42) \ud83e\uddea Simulate Sampling Distribution Function to generate and plot sampling distributions: def simulate_sampling_distribution(population, sample_sizes, n_simulations=1000): for n in sample_sizes: sample_means = [] for _ in range(n_simulations): sample = np.random.choice(population, size=n, replace=True) sample_means.append(np.mean(sample)) plt.figure(figsize=(7, 4)) sns.histplot(sample_means, kde=True, stat=\"density\", bins=30, color='skyblue') plt.title(f\"Sampling Distribution (n={n})\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Density\") plt.grid(True) plt.show() \ud83e\uddee Create Population and Run Simulation # Create a skewed population (Exponential) population = np.random.exponential(scale=2.0, size=100_000) # Sample sizes to explore sample_sizes = [5, 10, 30, 50] # Run the simulation simulate_sampling_distribution(population, sample_sizes) \ud83d\udccc Interpretation 1. Effect of Original Distribution : Since exponential is skewed , small sample sizes yield skewed sample mean distributions . As n increases , the distribution of sample means becomes more normal , despite the original skewness. 2. Effect of Sample Size : Larger sample sizes (n \u2265 30) yield sample mean distributions that are approximately normal . CLT holds better for larger n. 3. Effect of Population Variance : Let\u2019s test different variances: # Compare two exponential populations with different variances population_low_var = np.random.exponential(scale=1.0, size=100_000) # Lower variance population_high_var = np.random.exponential(scale=3.0, size=100_000) # Higher variance simulate_sampling_distribution(population_low_var, [30]) simulate_sampling_distribution(population_high_var, [30]) The higher the population variance , the wider the sampling distribution . But shape (normality) remains consistent as long as sample size is sufficient. \u2705 Summary: Skewed populations need larger samples to produce normally distributed sample means. Larger sample sizes increase accuracy of CLT. Higher variance \u2192 wider sampling distributions, but doesn\u2019t affect shape of convergence. Let me know when you're ready for Task 1.4: Practical Applications or the next major problem.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-1-simulating-population-distributions","text":"In this first part of the Central Limit Theorem (CLT) exploration, we begin by creating large datasets to represent different types of population distributions: Uniform Distribution : Values are equally likely within a range (0 to 10). Exponential Distribution : Skewed right; models wait times or lifetimes (scale = 2). Binomial Distribution : Discrete distribution representing the number of successes in 10 trials with probability 0.5. The histograms above visualize the shape of each distribution. These populations will be used in the next task to sample and observe how the sample means behave according to the CLT. Let me know if you're ready to proceed to Task 2: Sampling and Visualization .","title":"Task 1: Simulating Population Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-2-sampling-and-visualization","text":"We now investigate how sample size affects the distribution of sample means for different population types (Uniform, Exponential, Binomial). For each case: We take random samples of sizes 5, 10, 30, and 50. We compute the mean of each sample. We repeat this process 1000 times to build a sampling distribution . Then we plot histograms to visualize how these sample means begin to resemble a normal distribution as the sample size increases.","title":"Task 2: Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#observations","text":"For small sample sizes (e.g., 5), the sampling distribution reflects the skewness of the original population. As the sample size increases, all sampling distributions begin to take on a bell-shaped curve , aligning with the Central Limit Theorem . The convergence to normality occurs faster for symmetric distributions (like Uniform or Binomial) compared to skewed ones (like Exponential). Let me know when you\u2019re ready for Task 3: Parameter Exploration . T\u0259\u015f\u0259kk\u00fcr edir\u0259m! B\u0259li, haql\u0131s\u0131n\u0131z \u2014 1-ci \u0259sas tap\u015f\u0131r\u0131\u011f\u0131n i\u00e7ind\u0259 3 alt tap\u015f\u0131r\u0131q var idi, v\u0259 indi g\u0259lin 3-c\u00fcn\u00fc (Parameter Exploration) tam \u015f\u0259kild\u0259 h\u0259ll ed\u0259k (simulyasiya v\u0259 kodla birlikd\u0259).","title":"\ud83d\udd0d Observations:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-13-parameter-exploration-simulation-and-analysis","text":"","title":"\u2705 Task 1.3: Parameter Exploration \u2014 Simulation and Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_1/#goal","text":"To understand how the original distribution , sample size , and population variance affect the shape and spread of the sampling distribution of the mean .","title":"\ud83c\udfaf Goal:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#simulation-with-python","text":"We'll use the Exponential distribution (which is skewed) and vary the sample sizes to see the effect on the distribution of sample means.","title":"\ud83d\udcca Simulation with Python"},{"location":"1%20Physics/6%20Statistics/Problem_1/#libraries","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns np.random.seed(42)","title":"\u2705 Libraries:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#simulate-sampling-distribution","text":"","title":"\ud83e\uddea Simulate Sampling Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#function-to-generate-and-plot-sampling-distributions","text":"def simulate_sampling_distribution(population, sample_sizes, n_simulations=1000): for n in sample_sizes: sample_means = [] for _ in range(n_simulations): sample = np.random.choice(population, size=n, replace=True) sample_means.append(np.mean(sample)) plt.figure(figsize=(7, 4)) sns.histplot(sample_means, kde=True, stat=\"density\", bins=30, color='skyblue') plt.title(f\"Sampling Distribution (n={n})\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Density\") plt.grid(True) plt.show()","title":"Function to generate and plot sampling distributions:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#create-population-and-run-simulation","text":"# Create a skewed population (Exponential) population = np.random.exponential(scale=2.0, size=100_000) # Sample sizes to explore sample_sizes = [5, 10, 30, 50] # Run the simulation simulate_sampling_distribution(population, sample_sizes)","title":"\ud83e\uddee Create Population and Run Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#interpretation","text":"","title":"\ud83d\udccc Interpretation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-effect-of-original-distribution","text":"Since exponential is skewed , small sample sizes yield skewed sample mean distributions . As n increases , the distribution of sample means becomes more normal , despite the original skewness.","title":"1. Effect of Original Distribution:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-effect-of-sample-size","text":"Larger sample sizes (n \u2265 30) yield sample mean distributions that are approximately normal . CLT holds better for larger n.","title":"2. Effect of Sample Size:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-effect-of-population-variance","text":"Let\u2019s test different variances: # Compare two exponential populations with different variances population_low_var = np.random.exponential(scale=1.0, size=100_000) # Lower variance population_high_var = np.random.exponential(scale=3.0, size=100_000) # Higher variance simulate_sampling_distribution(population_low_var, [30]) simulate_sampling_distribution(population_high_var, [30]) The higher the population variance , the wider the sampling distribution . But shape (normality) remains consistent as long as sample size is sufficient.","title":"3. Effect of Population Variance:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#summary","text":"Skewed populations need larger samples to produce normally distributed sample means. Larger sample sizes increase accuracy of CLT. Higher variance \u2192 wider sampling distributions, but doesn\u2019t affect shape of convergence. Let me know when you're ready for Task 1.4: Practical Applications or the next major problem.","title":"\u2705 Summary:"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 M\u0259n Problem 1 \u00fc\u00e7\u00fcn tam riyazi \u0259sasland\u0131rman\u0131 v\u0259 Python simulyasiyas\u0131n\u0131 t\u0259qdim etdim. Bu kod s\u0259n\u0259di art\u0131q yarad\u0131l\u0131b v\u0259 a\u015fa\u011f\u0131dak\u0131lara cavab verir: \u2705 \u018fhat\u0259 olunan hiss\u0259l\u0259r: Riyazi \u0259sasland\u0131rma: Yatay v\u0259 \u015faquli h\u0259r\u0259k\u0259tin t\u0259nlikl\u0259ri U\u00e7u\u015f m\u00fcdd\u0259ti v\u0259 m\u0259saf\u0259 \u00fc\u00e7\u00fcn \u00e7\u0131xar\u0131lm\u0131\u015f d\u00fcsturlar \u0130deal modelin s\u0259rh\u0259dl\u0259ri Python kodu il\u0259 simulyasiya: At\u0131\u015f buca\u011f\u0131ndan as\u0131l\u0131 olaraq m\u0259saf\u0259nin qrafiki M\u00fcxt\u0259lif ba\u015flan\u011f\u0131c s\u00fcr\u0259tl\u0259ri \u00fc\u00e7\u00fcn m\u00fcqayis\u0259li qrafik N\u0259tic\u0259l\u0259rin vizualizasiyas\u0131: 0\u201390\u00b0 bucaqlar\u0131 \u00fczr\u0259 m\u0259saf\u0259nin qrafiki F\u0259rqli v\u2080 qiym\u0259tl\u0259ri \u00fc\u00e7\u00fcn t\u0259sir analizi \u26a0 G\u0259l\u0259c\u0259k m\u0259rh\u0259l\u0259l\u0259r (\u0259g\u0259r ist\u0259yirs\u0259ns\u0259): H\u00fcnd\u00fcr ba\u015flan\u011f\u0131c n\u00f6qt\u0259si daxil edilsin Hava m\u00fcqavim\u0259ti (drag force) modell\u0259\u015fdirilsin Reall\u0131\u011fa daha yax\u0131n n\u00fcmun\u0259l\u0259r simulyasiya olunsun (idman, top at\u0131\u015f\u0131, v\u0259 s.) \u018fg\u0259r Problem 2 d\u0259 bu m\u00f6vzunun davam\u0131d\u0131rsa v\u0259 ya ba\u015fqa bir m\u0259s\u0259l\u0259y\u0259 aiddirs\u0259, z\u0259hm\u0259t olmasa onu tam \u015f\u0259kild\u0259 payla\u015f \u2014 onu da h\u0259ll edim. Riyazi \u0259sasland\u0131rma: Yatay v\u0259 \u015faquli h\u0259r\u0259k\u0259tin t\u0259nlikl\u0259ri U\u00e7u\u015f m\u00fcdd\u0259ti v\u0259 m\u0259saf\u0259 \u00fc\u00e7\u00fcn \u00e7\u0131xar\u0131lm\u0131\u015f d\u00fcsturlar \u0130deal modelin s\u0259rh\u0259dl\u0259ri Python kodu il\u0259 simulyasiya: At\u0131\u015f buca\u011f\u0131ndan as\u0131l\u0131 olaraq m\u0259saf\u0259nin qrafiki M\u00fcxt\u0259lif ba\u015flan\u011f\u0131c s\u00fcr\u0259tl\u0259ri \u00fc\u00e7\u00fcn m\u00fcqayis\u0259li qrafik N\u0259tic\u0259l\u0259rin vizualizasiyas\u0131: 0\u201390\u00b0 bucaqlar\u0131 \u00fczr\u0259 m\u0259saf\u0259nin qrafiki F\u0259rqli v\u2080 qiym\u0259tl\u0259ri \u00fc\u00e7\u00fcn t\u0259sir analizi","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"M\u0259n Problem 1 \u00fc\u00e7\u00fcn tam riyazi \u0259sasland\u0131rman\u0131 v\u0259 Python simulyasiyas\u0131n\u0131 t\u0259qdim etdim. Bu kod s\u0259n\u0259di art\u0131q yarad\u0131l\u0131b v\u0259 a\u015fa\u011f\u0131dak\u0131lara cavab verir:","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#hat-olunan-hisslr","text":"Riyazi \u0259sasland\u0131rma: Yatay v\u0259 \u015faquli h\u0259r\u0259k\u0259tin t\u0259nlikl\u0259ri U\u00e7u\u015f m\u00fcdd\u0259ti v\u0259 m\u0259saf\u0259 \u00fc\u00e7\u00fcn \u00e7\u0131xar\u0131lm\u0131\u015f d\u00fcsturlar \u0130deal modelin s\u0259rh\u0259dl\u0259ri Python kodu il\u0259 simulyasiya: At\u0131\u015f buca\u011f\u0131ndan as\u0131l\u0131 olaraq m\u0259saf\u0259nin qrafiki M\u00fcxt\u0259lif ba\u015flan\u011f\u0131c s\u00fcr\u0259tl\u0259ri \u00fc\u00e7\u00fcn m\u00fcqayis\u0259li qrafik N\u0259tic\u0259l\u0259rin vizualizasiyas\u0131: 0\u201390\u00b0 bucaqlar\u0131 \u00fczr\u0259 m\u0259saf\u0259nin qrafiki F\u0259rqli v\u2080 qiym\u0259tl\u0259ri \u00fc\u00e7\u00fcn t\u0259sir analizi","title":"\u2705 \u018fhat\u0259 olunan hiss\u0259l\u0259r:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#glck-mrhllr-gr-istyirsns","text":"H\u00fcnd\u00fcr ba\u015flan\u011f\u0131c n\u00f6qt\u0259si daxil edilsin Hava m\u00fcqavim\u0259ti (drag force) modell\u0259\u015fdirilsin Reall\u0131\u011fa daha yax\u0131n n\u00fcmun\u0259l\u0259r simulyasiya olunsun (idman, top at\u0131\u015f\u0131, v\u0259 s.) \u018fg\u0259r Problem 2 d\u0259 bu m\u00f6vzunun davam\u0131d\u0131rsa v\u0259 ya ba\u015fqa bir m\u0259s\u0259l\u0259y\u0259 aiddirs\u0259, z\u0259hm\u0259t olmasa onu tam \u015f\u0259kild\u0259 payla\u015f \u2014 onu da h\u0259ll edim. Riyazi \u0259sasland\u0131rma: Yatay v\u0259 \u015faquli h\u0259r\u0259k\u0259tin t\u0259nlikl\u0259ri U\u00e7u\u015f m\u00fcdd\u0259ti v\u0259 m\u0259saf\u0259 \u00fc\u00e7\u00fcn \u00e7\u0131xar\u0131lm\u0131\u015f d\u00fcsturlar \u0130deal modelin s\u0259rh\u0259dl\u0259ri Python kodu il\u0259 simulyasiya: At\u0131\u015f buca\u011f\u0131ndan as\u0131l\u0131 olaraq m\u0259saf\u0259nin qrafiki M\u00fcxt\u0259lif ba\u015flan\u011f\u0131c s\u00fcr\u0259tl\u0259ri \u00fc\u00e7\u00fcn m\u00fcqayis\u0259li qrafik N\u0259tic\u0259l\u0259rin vizualizasiyas\u0131: 0\u201390\u00b0 bucaqlar\u0131 \u00fczr\u0259 m\u0259saf\u0259nin qrafiki F\u0259rqli v\u2080 qiym\u0259tl\u0259ri \u00fc\u00e7\u00fcn t\u0259sir analizi","title":"\u26a0 G\u0259l\u0259c\u0259k m\u0259rh\u0259l\u0259l\u0259r (\u0259g\u0259r ist\u0259yirs\u0259ns\u0259):"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"}]}